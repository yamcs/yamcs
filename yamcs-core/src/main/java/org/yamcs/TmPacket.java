package org.yamcs;

import java.util.List;

import org.yamcs.archive.XtceTmRecorder;
import org.yamcs.parameter.ParameterValue;
import org.yamcs.time.Instant;
import org.yamcs.utils.TimeEncoding;
import org.yamcs.xtce.SequenceContainer;
import org.yamcs.xtce.XtceDb;
import org.yamcs.yarch.DataType;
import org.yamcs.yarch.Tuple;
import org.yamcs.yarch.TupleDefinition;

/**
 * Packet with acquisition time, generation time and sequence count.
 * 
 * <p>
 * It is assumed that (generation time, sequence count) uniquely identifies the packet
 * 
 * <p>
 * Starting with yamcs 4.11 there is a 32 bitfield status that can be set on the packets by the pre-processor. The bits
 * currently defined:
 * <ul>
 * <li>bit 0 (msb) - always 0</li>
 * <li>bits 1-15 - user defined (pre-processor specific)</li>
 * <li>bits 16-28 - reserved for future Yamcs use</li>
 * <li>bit 29 - DO_NOT_ARCHIVE - the {@link XtceTmRecorder} will not archive the packets that have this bit set.</li>
 * <li>bit 30 - LOCAL_GEN_TIME - when the pre-processor cannot find the generation time, it can use the local time
 * instead and set this bit</li>
 * <li>bit 31(lsb) - INVALID - used for example when the packet fails crc or checksum verification</li>
 * </ul>
 * 
 * <p>
 * For the invalid packets there is an option at the link level to redirect them on a different stream. Using StreamSQL
 * any other packet can be redirected as well.
 * 
 *
 */
public class TmPacket {
    final public static int STATUS_MASK_INVALID = 1 << 0;
    final public static int STATUS_MASK_LOCAL_GEN_TIME = 1 << 1;
    final public static int STATUS_MASK_DO_NOT_ARCHIVE = 1 << 2;

    private long rectime = TimeEncoding.INVALID_INSTANT; // Yamcs reception time
    private long gentime = TimeEncoding.INVALID_INSTANT; // generation time
    private Instant ertime = Instant.INVALID_INSTANT; // earth reception time
    /**
     * If this packet has been extracted from a CCSDS frame, this is the sequence count of the frame containing the last
     * byte of the packet.
     * <p>
     * It is the same frame that contained the ertime
     */
    private long frameSeqCount = -1;

    private long obt = Long.MIN_VALUE;// on-board time when the time is free running
    private int seqCount;
    private byte[] pkt;
    private int status;

    // link on which the TM packet has been received
    private String link;


    // Preferred root container
    private SequenceContainer rootContainer;

    // metadata associated to the packet.
    // will be used by the frame decoder to store the vcId of frames where the packets have been extracted from
    private List<ParameterValue> metadata;

    public TmPacket(long rectime, byte[] pkt) {
        this.rectime = rectime;
        this.pkt = pkt;
    }

    public TmPacket(long rectime, long gentime, int seqCount, byte[] pkt) {
        this.rectime = rectime;
        this.gentime = gentime;
        this.seqCount = seqCount;
        this.pkt = pkt;
    }

    /**
     * The time when the packet has been generated by the payload.
     * 
     * @return
     */
    public long getGenerationTime() {
        return gentime;
    }

    public void setGenerationTime(long time) {
        this.gentime = time;
    }

    /**
     * Return the time when the packet has been received in Yamcs.
     * 
     * @return
     */
    public long getReceptionTime() {
        return rectime;
    }

    /**
     * The sequence count together with the generation time are supposed to uniquely identify the packet.
     * <p>
     * Note that for CCSDS space packets (as per CCSDS 133.0-B), this sequence count is a combination of the application
     * identifier(APID) and packet sequence count.
     * <p>
     * This means that the sequence count cannot be directly used to asses packet loss or packet ordering without having
     * more information about the nature of the count.
     * 
     * @return
     */
    public int getSeqCount() {
        return seqCount;
    }

    public void setSequenceCount(int seqCount) {
        this.seqCount = seqCount;
    }

    public byte[] getPacket() {
        return pkt;
    }

    public int length() {
        return pkt.length;
    }

    public void setInvalid() {
        status |= STATUS_MASK_INVALID;
    }

    public void setInvalid(boolean invalid) {
        status = invalid ? status | STATUS_MASK_INVALID : status & ~STATUS_MASK_INVALID;
    }

    public boolean isInvalid() {
        return (status & STATUS_MASK_INVALID) > 0;
    }

    /**
     * Returns the time when the packet has been received on earth or {@link TimeEncoding#INVALID_INSTANT} if it has not
     * been set.
     * <p>
     * The exact time returned will depend on how the packet has been received. For SLE links it will be the time when
     * the first bit of the last containing frame has been received at the ground station.
     * <p>
     * Some links will not set this parameter.
     * <p>
     * The reason this uses a high resolution instant whereas the others are using millisecond resolution times is that
     * the ground stations usually have high resolution clocks able to provide this accuracy. This is also the time used
     * to perform space to ground time synchronisation.
     * 
     * 
     * @return the time of the reception of the packet on ground.
     */
    public Instant getEarthReceptionTime() {
        return ertime;
    }

    public void setEarthReceptionTime(Instant ertime) {
        this.ertime = ertime;
    }

    /**
     * Use {@link #setEarthReceptionTime(Instant)} instead. (typo fix)
     */
    @Deprecated
    public void setEarthRceptionTime(Instant ertime) {
        setEarthReceptionTime(ertime);
    }

    public SequenceContainer getRootContainer() {
        return rootContainer;
    }

    public void setRootContainer(SequenceContainer rootContainer) {
        this.rootContainer = rootContainer;
    }

    /**
     * Set the flag that this packet generation time is in fact local time.
     */
    public void setLocalGenTimeFlag() {
        status |= STATUS_MASK_LOCAL_GEN_TIME;
    }

    /**
     * Sets the flag that this packet will not be archived.
     */
    public void setDoNotArchive() {
        status |= STATUS_MASK_DO_NOT_ARCHIVE;
    }

    /**
     * The 32bit flag.
     * <p>
     * Be aware that this will change also the values set by the setInvalid
     * 
     * @return
     */
    public int getStatus() {
        return status;
    }

    public void setStatus(int status) {
        this.status = status;
    }

    public long getObt() {
        return obt;
    }

    public void setObt(long obt) {
        this.obt = obt;
    }

    public long getFrameSeqCount() {
        return frameSeqCount;
    }

    public void setFrameSeqCount(long frameSeqCount) {
        this.frameSeqCount = frameSeqCount;
    }

    public String getLink() {
        return link;
    }

    public void setLink(String link) {
        this.link = link;
    }

    /**
     * Returns the metadata associated with this packet.
     *
     * @return the list of parameter values associated with this packet metadata, or null if not set
     */
    public List<ParameterValue> getMetadata() {
        return metadata;
    }

    /**
     * Sets the metadata associated with this packet.
     *
     * @param metadata the list of parameter values to associate with this packet
     */
    public void setMetadata(List<ParameterValue> metadata) {
        this.metadata = metadata;
    }

    /**
     * Adds a parameter to the metadata of this packet.
     * <p>
     * If metadata has not been initialized yet, it will be initialized as an ArrayList.
     *
     * @param param the parameter value to add to the metadata
     */
    public void addMetadataParameter(ParameterValue param) {
        if (metadata == null) {
            metadata = new java.util.ArrayList<>();
        }
        metadata.add(param);
    }

    /**
     * Creates a tuple representation of this packet for TM stream emission.
     *
     * @param linkName the name of the link on which this packet was received
     * @return a Tuple with StandardTupleDefinitions.TM schema, or extended schema if metadata is present
     */
    public Tuple toTuple(String linkName) {
        Instant ertime = getEarthReceptionTime();
        if (ertime == Instant.INVALID_INSTANT) {
            ertime = null;
        }
        Long obt = getObt() == Long.MIN_VALUE ? null : getObt();
        String rootContainer = getRootContainer() != null
                ? getRootContainer().getQualifiedName()
                : null;

        if (metadata == null || metadata.isEmpty()) {
            return new Tuple(StandardTupleDefinitions.TM, new Object[] {
                    gentime,
                    seqCount,
                    rectime,
                    status,
                    pkt,
                    ertime,
                    obt,
                    linkName,
                    rootContainer,
            });
        }

        // Create extended tuple definition with metadata columns
        TupleDefinition td = StandardTupleDefinitions.TM.copy();
        Object[] values = new Object[9 + metadata.size()];
        values[0] = gentime;
        values[1] = seqCount;
        values[2] = rectime;
        values[3] = status;
        values[4] = pkt;
        values[5] = ertime;
        values[6] = obt;
        values[7] = linkName;
        values[8] = rootContainer;

        for (int i = 0; i < metadata.size(); i++) {
            ParameterValue pv = metadata.get(i);
            if (pv.getGenerationTime() == TimeEncoding.INVALID_INSTANT) {
                pv.setGenerationTime(gentime);
            }
            if (pv.getAcquisitionTime() == TimeEncoding.INVALID_INSTANT) {
                pv.setAcquisitionTime(rectime);
            }
            String colName = pv.getParameterQualifiedName();
            td.addColumn(colName, DataType.PARAMETER_VALUE);
            values[9 + i] = pv;
        }

        return new Tuple(td, values);
    }

    /**
     * Creates a TmPacket from a tuple (typically from a TM stream).
     * <p>
     * Extracts the standard TM fields and any metadata parameters from the tuple.
     *
     * @param tuple the tuple to convert
     * @return a TmPacket with data populated from the tuple
     */
    public static TmPacket fromTuple(Tuple tuple) {
        long rectime = (Long) tuple.getColumn(StandardTupleDefinitions.TM_RECTIME_COLUMN);
        long gentime = (Long) tuple.getColumn(StandardTupleDefinitions.GENTIME_COLUMN);
        int seqCount = (Integer) tuple.getColumn(StandardTupleDefinitions.SEQNUM_COLUMN);
        byte[] packet = (byte[]) tuple.getColumn(StandardTupleDefinitions.TM_PACKET_COLUMN);

        TmPacket tmPacket = new TmPacket(rectime, gentime, seqCount, packet);

        String link = tuple.getColumn(StandardTupleDefinitions.TM_LINK_COLUMN);
        tmPacket.setLink(link);

        Instant ertime = tuple.getColumn(StandardTupleDefinitions.TM_ERTIME_COLUMN);
        if (ertime != null) {
            tmPacket.setEarthReceptionTime(ertime);
        }

        Long obt = tuple.getColumn(StandardTupleDefinitions.TM_OBT_COLUMN);
        if (obt != null) {
            tmPacket.setObt(obt);
        }

        int status = tuple.getColumn(StandardTupleDefinitions.TM_STATUS_COLUMN);
        tmPacket.setStatus(status);

        String preferredRootContainerName = tuple.getColumn(StandardTupleDefinitions.TM_ROOT_CONTAINER_COLUMN);
        if (preferredRootContainerName != null) {
            // Note: Root container cannot be resolved here without access to MDB
            // Set the name as a workaround (would need to be resolved externally)
            // tmPacket.setRootContainer(mdb.getSequenceContainer(preferredRootContainerName));
        }

        // Extract metadata parameters (if any)
        TupleDefinition td = tuple.getDefinition();
        for (int i = 0; i < td.size(); i++) {
            String colName = td.getColumn(i).getName();
            if (colName.startsWith(XtceDb.YAMCS_TM_PACKET_METADATA_SPACESYSTEM_NAME)) {
                ParameterValue pv = (ParameterValue) tuple.getColumn(i);
                if (pv != null) {
                    tmPacket.addMetadataParameter(pv);
                }
            }
        }

        return tmPacket;
    }

}
